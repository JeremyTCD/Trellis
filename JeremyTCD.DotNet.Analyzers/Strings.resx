<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CategoryName_Testing" xml:space="preserve">
    <value>Testing</value>
  </data>
  <data name="JA1000_Description" xml:space="preserve">
    <value>A unit test method's dummy local variable is not a mock of its type's interface.</value>
  </data>
  <data name="JA1000_MessageFormat" xml:space="preserve">
    <value>Dummy local variable should be a mock of its interface.</value>
  </data>
  <data name="JA1000_Title" xml:space="preserve">
    <value>Unit test methods must use interface mocks for dummies.</value>
  </data>
  <data name="JA1001_Description" xml:space="preserve">
    <value>A test class's namespace is incorrectly formatted.</value>
  </data>
  <data name="JA1001_MessageFormat" xml:space="preserve">
    <value>Test class namespace is not in the format "&lt;NamespaceOfClassUnderTest&gt;.Tests".</value>
  </data>
  <data name="JA1001_Title" xml:space="preserve">
    <value>Test class namespaces must be correctly formatted.</value>
  </data>
  <data name="JA1002_Description" xml:space="preserve">
    <value>A test class's name is incorrectly formatted.</value>
  </data>
  <data name="JA1002_MessageFormat" xml:space="preserve">
    <value>Test class name is not in the format "&lt;ClassUnderTest&gt;&lt;UnitTests|IntegrationTests|EndToEndTests&gt;".</value>
  </data>
  <data name="JA1002_Title" xml:space="preserve">
    <value>Test class names must be correctly formatted.</value>
  </data>
  <data name="JA1003_Description" xml:space="preserve">
    <value>A test method's name is incorrectly formatted.</value>
  </data>
  <data name="JA1003_MessageFormat" xml:space="preserve">
    <value>Test method name must be of the format "&lt;MethodUnderTest&gt;_&lt;TestDescription&gt;</value>
  </data>
  <data name="JA1003_Title" xml:space="preserve">
    <value>Test method names must be correctly formatted.</value>
  </data>
  <data name="JA1004_Description" xml:space="preserve">
    <value>A test method mock local variable's name is incorrectly formatted.</value>
  </data>
  <data name="JA1004_MessageFormat" xml:space="preserve">
    <value>Mock local variable name "{0}" is incorrectly formatted. 
- Instances or mocks of the class under test must be named "testSubject".
- Mocks with behaviours must have names starting with "mock".
- Mocks that do not have behaviours must have names starting with "dummy".</value>
  </data>
  <data name="JA1004_Title" xml:space="preserve">
    <value>Test method mock local variable names must be correctly formatted.</value>
  </data>
  <data name="JA1005_Description" xml:space="preserve">
    <value>A test subject is not instantiated by a valid create method.</value>
  </data>
  <data name="JA1005_MessageFormat" xml:space="preserve">
    <value>Use a valid create method to instantiate the object.</value>
  </data>
  <data name="JA1005_Title" xml:space="preserve">
    <value>Test subject must be instantiated in a valid create method.</value>
  </data>
  <data name="JA1006_Description" xml:space="preserve">
    <value>A test data method's name is incorrectly formatted.</value>
  </data>
  <data name="JA1006_MessageFormat" xml:space="preserve">
    <value>Test data method name must be of the format "&lt;TestMethod&gt;_Data"</value>
  </data>
  <data name="JA1006_Title" xml:space="preserve">
    <value>Test data method names must be correctly formatted.</value>
  </data>
  <data name="JA1007_Description" xml:space="preserve">
    <value>A documented exception throwing outcome has no matching unit test.</value>
  </data>
  <data name="JA1007_MessageFormat" xml:space="preserve">
    <value>Exception throwing outcome has no matching unit test.</value>
  </data>
  <data name="JA1007_Title" xml:space="preserve">
    <value>Documented exception outcomes must have matching unit tests.</value>
  </data>
  <data name="JA1008_Description" xml:space="preserve">
    <value>A test method that calls Mock&lt;T&gt;.Setup does not call MockRepository.VerifyAll.</value>
  </data>
  <data name="JA1008_MessageFormat" xml:space="preserve">
    <value>Test method must call MockRepository.VerifyAll.</value>
  </data>
  <data name="JA1008_Title" xml:space="preserve">
    <value>Test method must call MockRepository.VerifyAll if it calls Mock&lt;T&gt;.Setup.</value>
  </data>
  <data name="JA1009_Description" xml:space="preserve">
    <value>Mock&lt;T&gt;() used instead of MockRepository.Create.</value>
  </data>
  <data name="JA1009_MessageFormat" xml:space="preserve">
    <value>Use MockRepository.Create instead of Mock&lt;T&gt;().</value>
  </data>
  <data name="JA1009_Title" xml:space="preserve">
    <value>MockRepository.Create must be used instead of Mock&lt;T&gt;'s constructor.</value>
  </data>
  <data name="JA1010_Description" xml:space="preserve">
    <value>A test method's members are incorrectly ordered.</value>
  </data>
  <data name="JA1010_MessageFormat" xml:space="preserve">
    <value>Test method members must be correctly ordered.</value>
  </data>
  <data name="JA1010_Title" xml:space="preserve">
    <value>Test method members must be correctly ordered.</value>
  </data>
  <data name="JA1011_CodeFix_Title_CreateEndToEndTestClass" xml:space="preserve">
    <value>Create end to end test class...</value>
  </data>
  <data name="JA1011_CodeFix_Title_CreateIntegrationTestClass" xml:space="preserve">
    <value>Create integration test class...</value>
  </data>
  <data name="JA1011_CodeFix_Title_CreateUnitTestClass" xml:space="preserve">
    <value>Create unit test class...</value>
  </data>
  <data name="JA1012_Description" xml:space="preserve">
    <value>A test method has incorrectly named test subject local variables.</value>
  </data>
  <data name="JA1012_MessageFormat" xml:space="preserve">
    <value>Test method test subject local variables must be named "testSubject". If a method contains more than one such local variable, their named must end with "TestSubject".</value>
  </data>
  <data name="JA1012_Title" xml:space="preserve">
    <value>Test method test subject local variable names must be correctly formatted.</value>
  </data>
  <data name="JA1100_Description" xml:space="preserve">
    <value>A public property or method is not virtual.</value>
  </data>
  <data name="JA1100_MessageFormat" xml:space="preserve">
    <value>Property or method must be virtual.</value>
  </data>
  <data name="JA1100_Title" xml:space="preserve">
    <value>Public properties and methods must be virtual.</value>
  </data>
  <data name="JA1200_Description" xml:space="preserve">
    <value>A factory class's name is incorrectly formatted.</value>
  </data>
  <data name="JA1200_MessageFormat" xml:space="preserve">
    <value>Factory class name is not in format "&lt;ProducedType&gt;Factory" where &lt;ProducedType&gt; implements the interface that the factory produces.</value>
  </data>
  <data name="JA1200_Title" xml:space="preserve">
    <value>Factory class names must be correctly formatted.</value>
  </data>
  <data name="JA1201_Description" xml:space="preserve">
    <value>A factory interface's name is incorrectly formatted.</value>
  </data>
  <data name="JA1201_MessageFormat" xml:space="preserve">
    <value>Factory interface name is not in format "&lt;ProducedInterface&gt;Factory".</value>
  </data>
  <data name="JA1201_Title" xml:space="preserve">
    <value>Factory interface names must be correctly formatted.</value>
  </data>
  <data name="JA1202_Description" xml:space="preserve">
    <value>A factory interface does not have any valid create methods.</value>
  </data>
  <data name="JA1202_MessageFormat" xml:space="preserve">
    <value>Factory interface does not have a method named "Create" that returns the produced interface.</value>
  </data>
  <data name="JA1202_Title" xml:space="preserve">
    <value>Factory interface must have at least one valid create method.</value>
  </data>
  <data name="JA1203_Description" xml:space="preserve">
    <value>Factory class does not implement a factory interface.</value>
  </data>
  <data name="JA1203_MessageFormat" xml:space="preserve">
    <value>Factory class must implement a factory interface.</value>
  </data>
  <data name="JA1203_Title" xml:space="preserve">
    <value>Factory class must implement factory interface.</value>
  </data>
  <data name="JA1204_Description" xml:space="preserve">
    <value>A factory class ceate method does not return produced class.</value>
  </data>
  <data name="JA1204_MessageFormat" xml:space="preserve">
    <value>Create method must return produced class.</value>
  </data>
  <data name="JA1204_Title" xml:space="preserve">
    <value>Factory class create methods must return produced class.</value>
  </data>
</root>